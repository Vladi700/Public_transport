edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graph_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
LG = make_line_graph(g)
# 5) Quick plot
plot(LG,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graph_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
LG = make_line_graph(g)
# 5) Quick plot
plot(LG,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graphs_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
set.seed(1)
LG = make_line_graph(g)
# 5) Quick plot
plot(g,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graphs_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
set.seed(1)
LG = make_line_graph(g)
# 5) Quick plot
plot(LG,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graph_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
set.seed(1)
LG = make_line_graph(g)
# 5) Quick plot
plot(g,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graph_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
set.seed(1)
LG = make_line_graph(g)
# 5) Quick plot
plot(LG,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graph_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
set.seed(1)
LG = make_line_graph(g)
# 5) Quick plot
plot(g,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
E(g)$eid  <- as.character(edges$edge_id)
E(g)$eid  <- as.character(edges$line_id)
E(g)$name <- E(g)$eid
K = length(unique(edges$line_id))
E(g)$name <- as.character(seq_len(ecount(g)))
A  <- as.matrix(as_adjacency_matrix(g, sparse = FALSE))
deg <- rowSums(A); D <- diag(pmax(deg, 1e-12))
Lsym <- diag(nrow(A)) - solve(sqrt(D)) %*% A %*% solve(sqrt(D))
U <- eigs(Lsym, k = K, which = "SM")$vectors
cl <- kmeans(U, centers = K, nstart = 50)$cluster
edge_comm <- setNames(cl, V(g)$name)
E(g)$line_cluster <- as.integer(edge_comm[E(g)$name])
E(g)$line_cluster
E(g)$eid <- as.character(edges$edge_id)
E(g)$eid <- as.character(edges$line_id)
V(LG)$eid <- E(g)$eid
com <- cluster_leiden(LG, resolution_parameter = 1.0)
memb <- membership(com)
E(g)$line_cluster <- memb[ match(E(g)$eid, V(LG)$eid) ]
ggraph(G, layout = "manual",
x = as.numeric(V(g)$longitude),
y = as.numeric(V(g)$latitude)) +
geom_edge_link(aes(color = factor(line_cluster)), width = 1.6, lineend = "round") +
geom_node_point(size = 1.3, colour = "grey15") +
scale_edge_color_discrete(name = "Leiden line", na.translate = FALSE, na.value = "grey80") +
coord_fixed() + theme_void()
E(g)$eid <- as.character(edges$line_id)
V(LG)$eid <- E(g)$eid
com <- cluster_leiden(LG, resolution_parameter = 1.0)
memb <- membership(com)
E(g)$line_cluster <- memb[ match(E(g)$eid, V(LG)$eid) ]
ggraph(g, layout = "manual",
x = as.numeric(V(g)$longitude),
y = as.numeric(V(g)$latitude)) +
geom_edge_link(aes(color = factor(line_cluster)), width = 1.6, lineend = "round") +
geom_node_point(size = 1.3, colour = "grey15") +
scale_edge_color_discrete(name = "Leiden line", na.translate = FALSE, na.value = "grey80") +
coord_fixed() + theme_void()
E(g)$eid <- as.character(edges$line_id)
V(LG)$eid <- E(g)$eid
com <- cluster_leiden(LG, resolution_parameter = 1.0)
memb <- membership(com)
E(g)$line_cluster <- memb[ match(E(g)$eid, V(LG)$eid) ]
fc  <- factor(E(G)$line_cluster)
pal <- rainbow(nlevels(fc))            # simple built-in palette
edge_col <- pal[as.integer(fc)]
edge_col[is.na(edge_col)] <- "grey80"  # fallback for NAs
plot(G,
edge.color   = edge_col,
edge.width   = 2,
edge.curved  = 0,
vertex.size  = 3,
vertex.label = NA)
# (optional) legend
legend("topleft", bty = "n", title = "Line",
legend = levels(fc), col = pal, lwd = 3, cex = 0.9)
E(g)$eid <- as.character(edges$line_id)
V(LG)$eid <- E(g)$eid
com <- cluster_leiden(LG, resolution_parameter = 1.0)
memb <- membership(com)
E(g)$line_cluster <- memb[ match(E(g)$eid, V(LG)$eid) ]
fc  <- factor(E(g)$line_cluster)
pal <- rainbow(nlevels(fc))            # simple built-in palette
edge_col <- pal[as.integer(fc)]
plot(g,
edge.color   = edge_col,
edge.width   = 2,
edge.curved  = 0,
vertex.size  = 3,
vertex.label = NA)
# (optional) legend
legend("topleft", bty = "n", title = "Line",
legend = levels(fc), col = pal, lwd = 3, cex = 0.9)
E(g)
E(g)$color
# 1) Map node IDs -> labels
id2lab <- nodes %>% select(nodeID, nodeLabel)
# 2) Recode edges to label endpoints (this merges same-name stations)
E_lab <- edges %>%
left_join(id2lab, by = c("nodeID_from" = "nodeID")) %>%
rename(from = nodeLabel) %>%
left_join(id2lab, by = c("nodeID_to" = "nodeID")) %>%
rename(to = nodeLabel) %>%
filter(!is.na(from), !is.na(to), from != to) %>%
# keep separate edges per line/mode so one station connects to all its lines
distinct(from, to, .data$mode, .data$line_id)
# 3) Vertex table keyed by label
V_lab <- nodes %>%
distinct(nodeLabel, .keep_all = TRUE) %>%   # one row per station name
transmute(
name  = nodeLabel,        # igraph key
label = nodeLabel,        # nice label for plotting
city, latitude, longitude
)
# 4) Build graph (undirected)
g <- graph_from_data_frame(E_lab, vertices = V_lab, directed = FALSE)
set.seed(1)
LG = make_line_graph(g)
# 5) Quick plot
plot(g,
vertex.size = 4,
vertex.label = NA,        # swap to V(g)$label if you want names on
edge.width = 3,
edge.curved = 0.2,        # helps show multiple lines between same stations
edge.arrow.size = 0)
labs <- sort(unique(E(g)$line_cluster))
pal  <- setNames(hue_pal()(length(labs)), labs)
E(g)$line_cluster
E(g)$eid <- as.character(edges$line_id)
V(LG)$eid <- E(g)$eid
com <- cluster_leiden(LG, resolution_parameter = 1.0)
memb <- membership(com)
E(g)$line_cluster <- memb[ match(E(g)$eid, V(LG)$eid) ]
fc  <- factor(E(g)$line_cluster)
pal <- rainbow(nlevels(fc))
edge_col <- pal[as.integer(fc)]
plot(g,
edge.color   = edge_col,
edge.width   = 2,
edge.curved  = 0,
vertex.size  = 3,
vertex.label = NA)
# (optional) legend
legend("topleft", bty = "n", title = "Line",
legend = levels(fc), col = pal, lwd = 3, cex = 0.9)
E(g)$line_cluster
edges2 <- edges %>%
mutate(line_id = factor(line_id)) %>%
rename(from = nodeID_from, to = nodeID_to)
# vertices (from all IDs that appear)
verts <- tibble::tibble(name = sort(unique(c(edges2$from, edges2$to))))
g <- graph_from_data_frame(edges2, vertices = verts, directed = FALSE)
# color palette per line_id
levs <- levels(edges2$line_id)
pal  <- grDevices::hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges2$line_id)]
plot(
g,
layout = layout_with_fr(g),
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
edges2 <- edges %>%
mutate(line_id = factor(line_id)) %>%
rename(from = nodeID_from, to = nodeID_to)
# vertices (from all IDs that appear)
verts <- tibble::tibble(name = sort(unique(c(edges2$from, edges2$to))))
g <- graph_from_data_frame(edges2, vertices = verts, directed = FALSE)
# color palette per line_id
levs <- levels(edges2$line_id)
pal  <- grDevices::hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges2$line_id)]
plot(
g,
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
edges2 <- edges %>%
mutate(line_id = factor(line_id)) %>%
rename(from = nodeID_from, to = nodeID_to)
# vertices (from all IDs that appear)
verts <- tibble(name = sort(unique(c(edges2$from, edges2$to))))
g <- graph_from_data_frame(edges2, vertices = verts, directed = FALSE)
# color palette per line_id
levs <- levels(edges2$line_id)
pal  <- grDevices::hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges2$line_id)]
plot(
g,
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
edges2 <- edges %>%
mutate(line_id = factor(line_id)) %>%
rename(from = nodeID_from, to = nodeID_to)
# vertices (from all IDs that appear)
verts <- tibble(name = sort(unique(c(edges2$from, edges2$to))))
g <- graph_from_data_frame(edges2, vertices = verts, directed = FALSE)
# color palette per line_id
levs <- levels(edges2$line_id)
pal  <- hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges2$line_id)]
plot(
g,
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
edges2 <- edges %>%
mutate(line_id = factor(line_id)) %>%
rename(from = nodeID_from, to = nodeID_to)
# vertices (from all IDs that appear)
verts <- tibble(name = sort(unique(c(edges2$from, edges2$to))))
g <- graph_from_data_frame(edges2, vertices = verts, directed = FALSE)
# color palette per line_id
levs <- levels(edges2$line_id)
pal  <- hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges2$line_id)]
plot(
g,
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
edges2
# vertices (from all IDs that appear)
verts <- tibble(name = sort(unique(c(edges$nodeID_from, edges2$nodeID_to))))
g <- graph_from_data_frame(edges, vertices = verts, directed = FALSE)
# vertices (from all IDs that appear)
verts <- tibble(name = sort(unique(c(edges$nodeID_from, edges$nodeID_to))))
g <- graph_from_data_frame(edges, vertices = verts, directed = FALSE)
levs <- levels(edges$line_id)
pal  <- hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges$line_id)]
plot(
g,
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
# vertices (from all IDs that appear)
verts <- tibble(name = sort(unique(c(edges$nodeID_from, edges$nodeID_to))))
g <- graph_from_data_frame(edges, vertices = verts, directed = FALSE)
levs <- levels(edges$line_id)
pal  <- hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges$line_id)]
plot(
g,
edge.color = E(g)$color,
edge.width = 1.5,
vertex.size = 4,
vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
# vertices (from all IDs that appear)
edges2 <- edges %>%
rename(from = nodeID_from, to = nodeID_to) %>%
mutate(line_id = addNA(factor(line_id)))   # include NA as its own legend level
verts <- tibble(name = sort(unique(c(edges2$from, edges2$to))))
# 2) Graph
g <- graph_from_data_frame(edges2, vertices = verts, directed = FALSE)
# 3) Colors per line_id (safe indexing via factor codes)
levs <- levels(edges2$line_id)
pal  <- hcl.colors(length(levs), "Dark 3")
E(g)$color <- pal[as.integer(edges2$line_id)]
# 4) Stable layout + plot
set.seed(42)
lay <- layout_with_fr(g)
plot(
g, layout = lay,
edge.color = E(g)$color, edge.width = 1.5,
vertex.size = 4, vertex.label = NA,
main = "Network colored by line_id"
)
legend("topleft", legend = levs, col = pal, lwd = 3, cex = 0.7, bty = "n", title = "line_id")
LG   <- tryCatch(line_graph(g), error=function(e) line.graph(g))  # compatibility
com  <- cluster_leiden(LG, resolution_parameter = 1.0)
LG   <- tryCatch(line_graph(g), error=function(e) line.graph(g))  # compatibility
com  <- cluster_leiden(LG, resolution_parameter = 1.0)
LG   <- line_graph(g)
com  <- cluster_leiden(LG, resolution_parameter = 1.0)
LG   <- line_graph(g)
com  <- cluster_leiden(LG, resolution_parameter = 1.0)
LG <- line_graph(g)
LG
LG <- line_graph(g)
LG$fun()
LG <- line_graph(g)
com <- cluster_leiden(LG, resolution_parameter = 1.0)
LG <- line_graph(g)
typeof(LG)
com <- cluster_leiden(LG, resolution_parameter = 1.0)
LG <- igraph::line_graph(g)
typeof(LG)
com <- cluster_leiden(LG, resolution_parameter = 1.0)
stopifnot(igraph::is_igraph(g))              # g must be an igraph
LG <- igraph::line_graph(igraph::as.igraph(g))
# If you *still* somehow get the wrong thing, coerce or extract:
if (inherits(LG, "tbl_graph")) LG <- igraph::as.igraph(LG)
if (is.list(LG))              LG <- LG[[1]]
stopifnot(igraph::is_igraph(LG))
